name: CI-CD

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  CI:
    runs-on: ubuntu-latest
    steps:
      - name: Obtendo o Codigo
        uses: actions/checkout@v4.2.2

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Construcao e Envio da Imagem Docker
        uses: docker/build-push-action@v6
        with:
          context: ./src
          push: true
          file: ./src/Dockerfile
          tags: |
            sheila421/fake-shop-app:latest
            sheila421/fake-shop-app:v${{ github.run_number }}

  # NOVO JOB: Análise do SonarQube
  sonar_analysis:
    needs: CI
    runs-on: ubuntu-latest
    steps:
      - name: Obtendo o Codigo para Analise
        uses: actions/checkout@v4.2.2

      - name: Instalar 'jq' (necessário para parsear JSON do Quality Gate)
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Iniciar e Configurar SonarQube Local Temporario
        id: sonarqube_setup
        run: |
          SONARQUBE_CONTAINER_NAME="my-sonarqube-local"
          # Não defina SONAR_ADMIN_PASSWORD aqui se não for usar.
          # SONAR_ADMIN_PASSWORD="admin" # Senha inicial, você DEVE mudar no primeiro uso

          echo "Iniciando o contêiner SonarQube..."
          docker run -d --name ${SONARQUBE_CONTAINER_NAME} -p 9000:9000 -p 9092:9092 sonarqube:lts-community

          echo "Aguardando um tempo fixo para o SonarQube iniciar (isso pode levar alguns minutos)..."
          # Removido o loop de verificação de status. Agora apenas uma espera fixa.
          sleep 120 # Espere 2 minutos. Pode ajustar se necessário.

          # Este passo é onde o problema pode estar, se o SonarQube não iniciou.
          # Os logs do próximo passo nos dirão o que aconteceu.

          echo "SONAR_LOCAL_HOST_URL=http://localhost:9000" >> $GITHUB_ENV

      # NOVO PASSO: Exibir logs do contêiner SonarQube para depuração
      - name: Exibir logs do contêiner SonarQube
        if: failure() # Adicionado para exibir logs apenas se o passo anterior falhar
        run: |
          SONARQUBE_CONTAINER_NAME="my-sonarqube-local"
          echo "Capturando logs do contêiner ${SONARQUBE_CONTAINER_NAME}..."
          docker logs ${SONARQUBE_CONTAINER_NAME} || echo "Contêiner não encontrado ou não rodando. Nenhuma log para exibir."


      - name: Executar Analise do SonarScanner
        env:
          SONAR_HOST_URL: ${{ env.SONAR_LOCAL_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_LOCAL_TOKEN_GITHUB_SECRET }}
        run: |
          docker run --rm \
            -e SONAR_HOST_URL="${SONAR_HOST_URL}" \
            -e SONAR_TOKEN="${SONAR_TOKEN}" \
            -v "$(pwd):/usr/src" \
            sonarsource/sonar-scanner-cli \
            -Dsonar.projectKey="fake-shop-local" \
            -Dsonar.sources="src/" \
            -Dsonar.python.version="3.11" # Ajuste para a sua versão do Python

      - name: Verificar Quality Gate
        id: quality_gate_check
        run: |
          SONAR_PROJECT_KEY="fake-shop-local"
          SONAR_LOCAL_HOST="${{ env.SONAR_LOCAL_HOST_URL }}"
          
          # IMPORTANT: Ajuste a autenticação aqui se você estiver usando um token!
          # Se você usou o secret SONAR_LOCAL_TOKEN_GITHUB_SECRET para o scanner,
          # então para a API do Quality Gate você também DEVE usar o token.
          # Caso contrário, se for a primeira vez e você ainda não gerou um token,
          # pode usar admin:admin (lembre-se que a senha padrão "admin" será alterada na primeira vez)
          
          # Se usar o token gerado (RECOMENDADO para produção e workflows)
          AUTH_HEADER="Authorization: Bearer ${{ secrets.SONAR_LOCAL_TOKEN_GITHUB_SECRET }}"
          QUALITY_GATE_STATUS=$(curl -s -H "$AUTH_HEADER" "${SONAR_LOCAL_HOST}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" | jq -r .projectStatus.status)
          
          # Se usar admin:admin (apenas para a PRIMEIRA execução sem token)
          # QUALITY_GATE_STATUS=$(curl -s -u admin:admin "${SONAR_LOCAL_HOST}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" | jq -r .projectStatus.status)
          
          echo "Status do Quality Gate: ${QUALITY_GATE_STATUS}"
          
          if [ "${QUALITY_GATE_STATUS}" == "OK" ]; then
            echo "Quality Gate APROVADO! O deploy pode prosseguir."
            echo "quality_gate_passed=true" >> "$GITHUB_OUTPUT"
          else
            echo "Quality Gate FALHOU! O deploy será abortado."
            echo "quality_gate_passed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Parar e Remover SonarQube Local
        if: always()
        run: |
          SONARQUBE_CONTAINER_NAME="my-sonarqube-local"
          echo "Finalizando e removendo o contêiner SonarQube..."
          docker stop ${SONARQUBE_CONTAINER_NAME} > /dev/null 2>&1 || true
          docker rm ${SONARQUBE_CONTAINER_NAME} > /dev/null 2>&1 || true
          echo "Contêiner SonarQube removido."

  deploy:
    needs: [CI, sonar_analysis]
    if: needs.sonar_analysis.outputs.quality_gate_passed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            # ... (Seu script de deploy existente aqui) ...
            docker pull sheila421/fake-shop-app:latest

            docker stop fake-shop-app || true
            docker rm fake-shop-app || true
            docker stop fake-shop-db || true
            docker rm fake-shop-db || true

            docker network rm rede-da-sheila || true
            docker network create rede-da-sheila || true

            docker run -d --name fake-shop-db --network rede-da-sheila \
              -e POSTGRES_USER=ecommerce \
              -e POSTGRES_PASSWORD=Pg1234 \
              -e POSTGRES_DB=ecommerce \
              -p 8214:5432 \
              -v fake-shop-db-data:/var/lib/postgresql/data \
              postgres:15

            echo "DEBUG: Aguardando o banco de dados 'fake-shop-db' ficar disponível na porta 5432..."
            until docker exec fake-shop-db pg_isready -h localhost -p 5432 -U ecommerce; do
              echo "DEBUG: Banco de dados não está pronto ainda. Tentando novamente em 5 segundos..."
              sleep 5
            done
            echo "DEBUG: Banco de dados 'fake-shop-db' está pronto!"

            sleep 20

            DB_INTERNAL_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' fake-shop-db)
            echo "DEBUG: IP interno do fake-shop-db para migração e aplicação: $DB_INTERNAL_IP"

            docker run --rm --network rede-da-sheila \
              --env-file /home/fiona/.env \
              -e FLASK_APP=index.py \
              -e DB_HOST=$DB_INTERNAL_IP \
              sheila421/fake-shop-app:latest flask db upgrade
            MIGRATION_STATUS=$?
            if [ $MIGRATION_STATUS -ne 0 ]; then
              echo "ERRO: Migrações do banco de dados falharam! Verifique os logs da execução do workflow para mais detalhes."
              exit $MIGRATION_STATUS
            fi

            docker run -d --name fake-shop-app --network rede-da-sheila \
              --env-file /home/fiona/.env \
              -e DB_HOST=$DB_INTERNAL_IP \
              -p 8213:8213 sheila421/fake-shop-app:latest /app/entrypoint.sh

            sleep 5

            docker exec fake-shop-app env > /tmp/app_env_vars.txt
            docker logs fake-shop-app > /tmp/app_logs.txt

            echo "DEBUG: Logs e variáveis de ambiente salvos em /tmp/app_logs.txt e /tmp/app_env_vars.txt no servidor."
            echo "DEBUG: Acesse o servidor via SSH e use 'cat /tmp/app_env_vars.txt' e 'cat /tmp/app_logs.txt' para verificar."