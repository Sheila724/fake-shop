name: CI-CD

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  CI:
    runs-on: ubuntu-latest
    steps:
      - name: Obtendo o Codigo
        uses: actions/checkout@v4.2.2

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Construcao e Envio da Imagem Docker
        uses: docker/build-push-action@v6
        with:
          context: ./src # Garanta que este caminho seja o seu código-fonte
          push: true
          file: ./src/Dockerfile # Garanta que este caminho seja o seu Dockerfile
          tags: |
            sheila421/fake-shop-app:latest
            sheila421/fake-shop-app:v${{ github.run_number }}

  # NOVO JOB: Análise do SonarQube
  sonar_analysis:
    needs: CI # Este job só roda depois que o job CI termina
    runs-on: ubuntu-latest
    steps:
      - name: Obtendo o Codigo para Analise
        uses: actions/checkout@v4.2.2

      - name: Instalar 'jq' (necessário para parsear JSON do Quality Gate)
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Iniciar e Configurar SonarQube Local Temporario
        id: sonarqube_setup # Id para referenciar as saídas deste passo
        run: |
          SONARQUBE_CONTAINER_NAME="my-sonarqube-local"
          SONAR_LOCAL_HOST="http://localhost:9000"
          SONAR_ADMIN_PASSWORD="admin" # Senha inicial, você DEVE mudar no primeiro uso

          echo "Iniciando o contêiner SonarQube..."
          docker run -d --name ${SONARQUBE_CONTAINER_NAME} -p 9000:9000 -p 9092:9092 sonarqube:lts-community

          echo "Esperando o SonarQube iniciar..."
          for i in $(seq 1 60); do # Tenta por até 5 minutos (60*5s)
            STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${SONAR_LOCAL_HOST}/api/system/status)
            if [ "$STATUS_CODE" -eq 200 ]; then
              echo "SonarQube está online!"
              break
            fi
            echo "Tentativa $i: SonarQube ainda não está pronto. Status: $STATUS_CODE. Aguardando..."
            sleep 5
          done

          if [ "$STATUS_CODE" -ne 200 ]; then
            echo "Erro: SonarQube não iniciou a tempo. Abortando a pipeline."
            exit 1
          fi

          # --- Configurar o SonarQube pela primeira vez (se necessário) ---
          # Esta parte é crucial para a primeira execução do pipeline.
          # Você precisa gerar um token no SonarQube localmente.
          # Depois de rodar a primeira vez, vá para http://localhost:9000
          # Acesse com admin/admin, mude a senha, crie um token e armazene como secret no GitHub.
          # Aconselha-se usar a primeira vez manualmente, ou usar a API para gerar token automaticamente (mais complexo).
          # POR SIMPLICIDADE E PARA O TRABALHO DA FACULDADE, VAMOS USAR O USUÁRIO E SENHA PADRÃO PARA O QA GATE
          # MAS EM PRODUÇÃO, VOCÊ USARIA UM TOKEN PRÉ-CONFIGURADO.
          # Para gerar um token real via API (requer credenciais admin), descomente e use o seguinte:
          # LOCAL_SONAR_TOKEN=$(curl -s -X POST -u admin:${SONAR_ADMIN_PASSWORD} "${SONAR_LOCAL_HOST}/api/user_tokens/generate?name=github_actions_token" | jq -r .token)
          # echo "LOCAL_SONAR_TOKEN=${LOCAL_SONAR_TOKEN}" >> $GITHUB_OUTPUT
          # POR ENQUANTO, VAMOS APENAS EXPOR AS CREDENCIAIS PADRÃO OU PEDIR PARA VOCÊ CONFIGURAR MANUALMENTE

          # Para fins deste workflow, vamos usar as credenciais admin/admin para o Quality Gate.
          # Em um cenário real, você criaria um token no SonarQube local e o guardaria como um GitHub Secret.
          echo "SONAR_LOCAL_TOKEN_FOR_QA_GATE=admin:${SONAR_ADMIN_PASSWORD}" >> $GITHUB_ENV
          echo "SONAR_LOCAL_HOST_URL=${SONAR_LOCAL_HOST}" >> $GITHUB_ENV


      - name: Executar Analise do SonarScanner
        env:
          SONAR_HOST_URL: ${{ env.SONAR_LOCAL_HOST_URL }}
          # Para o SonarQube local, se você não gerou um token, pode usar as credenciais admin:admin
          # MAS É RECOMENDADO GERAR UM TOKEN APÓS A PRIMEIRA EXECUÇÃO LOCALMENTE
          SONAR_TOKEN: ${{ secrets.SONAR_LOCAL_TOKEN_GITHUB_SECRET }} # Crie este secret no GitHub com o token gerado localmente
        run: |
          docker run --rm \
            -e SONAR_HOST_URL="${SONAR_HOST_URL}" \
            -e SONAR_TOKEN="${SONAR_TOKEN}" \
            -v "$(pwd):/usr/src" \
            sonarsource/sonar-scanner-cli \
            -Dsonar.projectKey="fake-shop-local" \
            -Dsonar.sources="src/" \
            -Dsonar.python.version="3.11" # Ajuste para a sua versão do Python

      - name: Verificar Quality Gate
        id: quality_gate_check
        run: |
          SONAR_PROJECT_KEY="fake-shop-local"
          SONAR_LOCAL_HOST="${{ env.SONAR_LOCAL_HOST_URL }}"
          
          # Se você usar um token gerado e guardado como secret:
          # AUTH_HEADER="Authorization: Bearer ${{ secrets.SONAR_LOCAL_TOKEN_GITHUB_SECRET }}"
          # QUALITY_GATE_STATUS=$(curl -s -H "$AUTH_HEADER" "${SONAR_LOCAL_HOST}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" | jq -r .projectStatus.status)

          # Se usar admin:admin (para a primeira vez ou simplificado para faculdade):
          QUALITY_GATE_STATUS=$(curl -s -u admin:${SONAR_ADMIN_PASSWORD} "${SONAR_LOCAL_HOST}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" | jq -r .projectStatus.status)
          
          echo "Status do Quality Gate: ${QUALITY_GATE_STATUS}"
          
          if [ "${QUALITY_GATE_STATUS}" == "OK" ]; then
            echo "Quality Gate APROVADO! O deploy pode prosseguir."
            echo "quality_gate_passed=true" >> "$GITHUB_OUTPUT"
          else
            echo "Quality Gate FALHOU! O deploy será abortado."
            echo "quality_gate_passed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Parar e Remover SonarQube Local
        if: always() # Garante que este passo sempre rodará, mesmo se os anteriores falharem
        run: |
          SONARQUBE_CONTAINER_NAME="my-sonarqube-local"
          echo "Finalizando e removendo o contêiner SonarQube..."
          docker stop ${SONARQUBE_CONTAINER_NAME} > /dev/null 2>&1 || true
          docker rm ${SONARQUBE_CONTAINER_NAME} > /dev/null 2>&1 || true
          echo "Contêiner SonarQube removido."

  deploy:
    needs: [CI, sonar_analysis] # Depende tanto do CI quanto da análise do Sonar
    if: needs.sonar_analysis.outputs.quality_gate_passed == 'true' # SOMENTE RODA SE O QUALITY GATE PASSAR
    runs-on: ubuntu-latest
    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            # ... (Seu script de deploy existente aqui) ...
            # Não mude nada aqui, apenas cole seu script original de deploy.
            # Certifique-se que o Docker esteja instalado no servidor 201.23.3.86
            docker pull sheila421/fake-shop-app:latest

            docker stop fake-shop-app || true
            docker rm fake-shop-app || true
            docker stop fake-shop-db || true
            docker rm fake-shop-db || true

            docker network rm rede-da-sheila || true
            docker network create rede-da-sheila || true

            docker run -d --name fake-shop-db --network rede-da-sheila \
              -e POSTGRES_USER=ecommerce \
              -e POSTGRES_PASSWORD=Pg1234 \
              -e POSTGRES_DB=ecommerce \
              -p 8214:5432 \
              -v fake-shop-db-data:/var/lib/postgresql/data \
              postgres:15

            echo "DEBUG: Aguardando o banco de dados 'fake-shop-db' ficar disponível na porta 5432..."
            until docker exec fake-shop-db pg_isready -h localhost -p 5432 -U ecommerce; do
              echo "DEBUG: Banco de dados não está pronto ainda. Tentando novamente em 5 segundos..."
              sleep 5
            done
            echo "DEBUG: Banco de dados 'fake-shop-db' está pronto!"

            sleep 20 # Pequeno atraso ANTES de obter o IP do contêiner

            DB_INTERNAL_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' fake-shop-db)
            echo "DEBUG: IP interno do fake-shop-db para migração e aplicação: $DB_INTERNAL_IP"

            docker run --rm --network rede-da-sheila \
              --env-file /home/fiona/.env \
              -e FLASK_APP=index.py \
              -e DB_HOST=$DB_INTERNAL_IP \
              sheila421/fake-shop-app:latest flask db upgrade
            MIGRATION_STATUS=$?
            if [ $MIGRATION_STATUS -ne 0 ]; then
              echo "ERRO: Migrações do banco de dados falharam! Verifique os logs da execução do workflow para mais detalhes."
              exit $MIGRATION_STATUS
            fi

            docker run -d --name fake-shop-app --network rede-da-sheila \
              --env-file /home/fiona/.env \
              -e DB_HOST=$DB_INTERNAL_IP \
              -p 8213:8213 sheila421/fake-shop-app:latest /app/entrypoint.sh

            sleep 5

            docker exec fake-shop-app env > /tmp/app_env_vars.txt
            docker logs fake-shop-app > /tmp/app_logs.txt

            echo "DEBUG: Logs e variáveis de ambiente salvos em /tmp/app_logs.txt e /tmp/app_env_vars.txt no servidor."
            echo "DEBUG: Acesse o servidor via SSH e use 'cat /tmp/app_env_vars.txt' e 'cat /tmp/app_logs.txt' para verificar."