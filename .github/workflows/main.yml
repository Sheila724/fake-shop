name: CI-CD

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  CI:
    runs-on: ubuntu-latest
    steps:
      - name: Obtendo o Codigo
        uses: actions/checkout@v4.2.2

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Construcao e Envio da Imagem Docker
        uses: docker/build-push-action@v6
        with:
          context: ./src
          push: true
          file: ./src/Dockerfile
          tags: |
            sheila421/fake-shop-app:latest
            sheila421/fake-shop-app:v${{ github.run_number }}

  sonar_analysis:
    needs: CI
    runs-on: ubuntu-latest
    steps:
      - name: Obtendo o Codigo para Analise
        uses: actions/checkout@v4.2.2

      - name: Instalar 'jq' e 'curl'
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Iniciar e Configurar SonarQube Local Temporario
        id: sonarqube_setup
        run: |
          SONARQUBE_CONTAINER_NAME="my-sonarqube-local"
          SONAR_LOCAL_HOST="http://localhost:9000"
          SONAR_ADMIN_PASSWORD="admin" # Senha padrão. Será usada para autenticação se necessário.

          echo "Iniciando o contêiner SonarQube..."
          docker run -d --name ${SONARQUBE_CONTAINER_NAME} -p 9000:9000 -p 9092:9092 sonarqube:lts-community

          echo "Esperando o SonarQube iniciar e estar acessível (isso pode levar alguns minutos)..."
          for i in $(seq 1 120); do # Aumentei o número de tentativas para 10 minutos (120 * 5s)
            # Tenta acessar a API de status do SonarQube
            STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${SONAR_LOCAL_HOST}/api/system/status)
            
            # Se você achar que a API de status precisa de autenticação (não deveria para status), use:
            # STATUS_CODE=$(curl -s -u admin:${SONAR_ADMIN_PASSWORD} -o /dev/null -w "%{http_code}" ${SONAR_LOCAL_HOST}/api/system/status)

            if [ "$STATUS_CODE" -eq 200 ]; then
              echo "SonarQube está online e acessível!"
              break
            fi
            echo "Tentativa $i: SonarQube ainda não está pronto. Status HTTP: $STATUS_CODE. Aguardando..."
            sleep 5
          done

          if [ "$STATUS_CODE" -ne 200 ]; then
            echo "Erro: SonarQube não iniciou ou não ficou acessível a tempo. Abortando a pipeline."
            # Exibir logs do contêiner antes de sair para depuração
            echo "--- Logs do SonarQube (antes de falhar) ---"
            docker logs ${SONARQUBE_CONTAINER_NAME} || true
            echo "-----------------------------------------"
            exit 1 # Força a falha do job
          fi
          
          echo "SONAR_LOCAL_HOST_URL=${SONAR_LOCAL_HOST}" >> $GITHUB_ENV


      - name: Executar Analise do SonarScanner
        env:
          SONAR_HOST_URL: ${{ env.SONAR_LOCAL_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_LOCAL_TOKEN_GITHUB_SECRET }} # Use seu secret com o token do SonarQube local
        run: |
          docker run --rm \
            -e SONAR_HOST_URL="${SONAR_HOST_URL}" \
            -e SONAR_TOKEN="${SONAR_TOKEN}" \
            -v "$(pwd):/usr/src" \
            sonarsource/sonar-scanner-cli \
            -Dsonar.projectKey="fake-shop-local" \
            -Dsonar.sources="src/" \
            -Dsonar.python.version="3.11" # Ajuste para a sua versão do Python

      - name: Verificar Quality Gate
        id: quality_gate_check
        run: |
          SONAR_PROJECT_KEY="fake-shop-local"
          SONAR_LOCAL_HOST="${{ env.SONAR_LOCAL_HOST_URL }}"
          
          # Pequena espera extra para garantir que a análise seja processada pelo SonarQube.
          sleep 10
          
          # Autenticação para a API do Quality Gate. Use o token do secret.
          AUTH_HEADER="Authorization: Bearer ${{ secrets.SONAR_LOCAL_TOKEN_GITHUB_SECRET }}"
          QUALITY_GATE_STATUS=$(curl -s -H "$AUTH_HEADER" "${SONAR_LOCAL_HOST}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" | jq -r .projectStatus.status)

          # Se o token do secret não estiver configurado OU não funcionar, você pode tentar com admin:admin
          # QUALITY_GATE_STATUS=$(curl -s -u admin:admin "${SONAR_LOCAL_HOST}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" | jq -r .projectStatus.status)
          
          echo "Status do Quality Gate: ${QUALITY_GATE_STATUS}"
          
          if [ "${QUALITY_GATE_STATUS}" == "OK" ]; then
            echo "Quality Gate APROVADO! O deploy pode prosseguir."
            echo "quality_gate_passed=true" >> "$GITHUB_OUTPUT"
          else
            echo "Quality Gate FALHOU! O deploy será abortado."
            echo "quality_gate_passed=false" >> "$GITHUB_OUTPUT"
            exit 1 # Falha o job explicitamente se o Quality Gate não aprovar
          fi

      - name: Parar e Remover SonarQube Local
        if: always() # Garante que este passo sempre rodará, mesmo se os anteriores falharem
        run: |
          SONARQUBE_CONTAINER_NAME="my-sonarqube-local"
          echo "Finalizando e removendo o contêiner SonarQube..."
          # Adicione o '|| true' para evitar que o comando falhe se o contêiner já estiver parado/removido
          docker stop ${SONARQUBE_CONTAINER_NAME} > /dev/null 2>&1 || true
          docker rm ${SONARQUBE_CONTAINER_NAME} > /dev/null 2>&1 || true
          echo "Contêiner SonarQube removido."

  deploy:
    needs: [CI, sonar_analysis]
    if: needs.sonar_analysis.outputs.quality_gate_passed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            # ... (Seu script de deploy existente aqui) ...
            docker pull sheila421/fake-shop-app:latest

            docker stop fake-shop-app || true
            docker rm fake-shop-app || true
            docker stop fake-shop-db || true
            docker rm fake-shop-db || true

            docker network rm rede-da-sheila || true
            docker network create rede-da-sheila || true

            docker run -d --name fake-shop-db --network rede-da-sheila \
              -e POSTGRES_USER=ecommerce \
              -e POSTGRES_PASSWORD=Pg1234 \
              -e POSTGRES_DB=ecommerce \
              -p 8214:5432 \
              -v fake-shop-db-data:/var/lib/postgresql/data \
              postgres:15

            echo "DEBUG: Aguardando o banco de dados 'fake-shop-db' ficar disponível na porta 5432..."
            until docker exec fake-shop-db pg_isready -h localhost -p 5432 -U ecommerce; do
              echo "DEBUG: Banco de dados não está pronto ainda. Tentando novamente em 5 segundos..."
              sleep 5
            done
            echo "DEBUG: Banco de dados 'fake-shop-db' está pronto!"

            sleep 20

            DB_INTERNAL_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' fake-shop-db)
            echo "DEBUG: IP interno do fake-shop-db para migração e aplicação: $DB_INTERNAL_IP"

            docker run --rm --network rede-da-sheila \
              --env-file /home/fiona/.env \
              -e FLASK_APP=index.py \
              -e DB_HOST=$DB_INTERNAL_IP \
              sheila421/fake-shop-app:latest flask db upgrade
            MIGRATION_STATUS=$?
            if [ $MIGRATION_STATUS -ne 0 ]; then
              echo "ERRO: Migrações do banco de dados falharam! Verifique os logs da execução do workflow para mais detalhes."
              exit $MIGRATION_STATUS
            fi

            docker run -d --name fake-shop-app --network rede-da-sheila \
              --env-file /home/fiona/.env \
              -e DB_HOST=$DB_INTERNAL_IP \
              -p 8213:8213 sheila421/fake-shop-app:latest /app/entrypoint.sh

            sleep 5

            docker exec fake-shop-app env > /tmp/app_env_vars.txt
            docker logs fake-shop-app > /tmp/app_logs.txt

            echo "DEBUG: Logs e variáveis de ambiente salvos em /tmp/app_logs.txt e /tmp/app_env_vars.txt no servidor."
            echo "DEBUG: Acesse o servidor via SSH e use 'cat /tmp/app_env_vars.txt' e 'cat /tmp/app_logs.txt' para verificar."